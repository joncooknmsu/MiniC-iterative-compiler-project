<html>
<head>
<title>
Compiler 1: hello world X86
</title>
</head>
<body>
<p>During the semester we are going to iteratively build up a compiler that compiles a reasonably complete programming language. A more traditional approach in a course is to have an assignment that builds a scanner for the complete language, then another assignment that builds the parser for the complete language, then another that builds code generation, and perhaps other steps. Instead, we are going to build the complete compiler pipeline for a small piece of the language first, and then add pieces to the language during each step. In software engineering, building a component at a time is an <strong>incremental</strong> approach, while building a whole application with only partial functionality, and then adding to it, is an <strong>iterative</strong> approach. Modern real-world software development <strong>by far</strong> uses the iterative approach more.</p>
<h3>Step 1 (this assignment): be able to compile a "hello world" C program</h3>
<p>For our first step, we are going to build a compiler that will accept a valid C "hello world" program, and that outputs valid x86_64 (64-bit Intel X86) assembly code that can be assembled into an executable program.</p>
<p>A simple program that gcc will compile (though with warnings) is:</p>
<pre>main()<br />{<br />   puts("Hello World!");<br />}</pre>
<p>As you can see, we are not including a function return type or any argument definitions, but a C compiler will still accept this as a valid C program, and it will run. Also, gcc optimizes calls to <em>printf()</em> that only have a single string argument -- it changes the call to be a call to <em>puts()</em> rather than <em>printf()</em>, because <em>puts</em> is simpler and faster. So we use <em>puts()</em> directly. And since our compiler will not use the <strong>C preprocessor</strong>, so we do not use any #include directives.</p>
<h3>Grammar needed for this assignment</h3>
<p>Program -&gt; Function<br />Function -&gt; ID LPAREN RPAREN LBRACE Statements RBRACE<br />Statements -&gt; Statement Statements | empty<br />Statement -&gt; FunCall<br />FunCall -&gt; ID LPAREN STRING RPAREN SEMICOLON</p>
<p>Note that this grammar will accept the simple program above, but will also match a program with multiple statements (as long as they are simple calls like the given one). Your assignment solution must work correctly for multiple statements.</p>
<h3>Scanner needed for this assignment</h3>
<p>In the grammar above, we see that our scanner needs to produce the following token types: ID, STRING, LPAREN, RPAREN, LBRACE, RBRACE, SEMICOLON. In your actual yacc grammar you will use these symbolic token types, rather than explicit characters for the required punctuation. The ID token type is for valid C identifiers and must have a string value associated with them (the actual identifier string). Valid C identifiers begin with a letter or underscore, and contain letters, numbers and underscores. The STRING token type matches a quoted string in the program source, and it must also have a string value associated with it (the actual string, including its beginning and ending quote characters). Your scanner must also skip unnecessary white space, including spaces, tabs, and newlines that are in between the tokens. Your scanner does not need to handle comments or anything else.</p>
<h3>Output required</h3>
<p>If we do "gcc -S" on the example program, which produces an assembly code file, we see its output as (annotated with right-hand-side comments from me):</p>
<pre>	.file	"test.c"            /* source descriptor, not really needed */<br />	.text                       /* must be in front of rodata section */<br />	.section	.rodata     /* beginning of const data section */<br />.LC0:                               /* label for string */<br />	.string	"Hello World!\n"    /* string constant */<br />	.text                       /* beginning of code section */<br />	.globl	main                /* declaring function main to be globally visible */<br />	.type	main, @function     /* declaring symbol main to be a function */<br />main:                               /* label for beginning of main function */<br />.LFB0:                              /* auto-generated label, not really needed */<br />	.cfi_startproc              /* function preamble */<br />	pushq	%rbp                /* function preamble */<br />	.cfi_def_cfa_offset 16      /* function preamble */<br />	.cfi_offset 6, -16          /* function preamble */<br />	movq	%rsp, %rbp          /* function preamble */<br />	.cfi_def_cfa_register 6     /* function preamble */<br />	leaq	.LC0(%rip), %rdi    /* place string argument address into argument register */<br />	call	puts@PLT            /* call function puts */<br />	movl	$0, %eax            /* main function ending; set return value */<br />	popq	%rbp                /* main function ending; restore rbp */<br />	.cfi_def_cfa 7, 8           /* main function ending; some directive */<br />	ret                         /* main function ending; return from function */<br />	.cfi_endproc                /* main function ending; some directive */<br />.LFE0:                              /* main function ending; auto-generated label, not used */<br />	.size	main, .-main        /* main function ending; size directive */<br />        /* stuff below here not needed */<br />	.ident	"GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0"<br />	.section	.note.GNU-stack,"",@progbits</pre>
<p>This might look complicated, but it's mostly constant or slightly formatted content. Each recognized program string must have a declaration in the data section. Each function must have a declaration that includes the preamble and the function ending. Then each function call statement must have the proper call, with argument setup and call instruction. Since all we are doing is only 1-string-argument calls, they all look exactly the same! Your output must follow this example pattern, and be assemble-able by gcc (gcc will act as an assembler if you give it a file with a .s extension).</p>
<h3>Requirements</h3>
<p>1. Must produce a lex/yacc-based compiler that compiles the hello world program into assembly code that <em>gcc</em> accepts and can produce an executable from. You may or may not have any C source files; this assignment is small enough that all you might have is your lex and yacc input source files.</p>
<p>2. Your program must allow zero or one command line arguments; if zero, read source input from stdin, if one, use it as a filename. The example lex/yacc code does this as well, so this is easy. Your program must output the assembly code on <em>stdout</em>. If you have other debugging output, either output it on <em>stderr</em> or be sure to turn it off or remove it before submission. Your <em>stdout</em> output should be able to be assembled by <em>gcc</em> into a working program, without any editing.</p>
<p>3. Your compiler must also correctly compile the same program but with multiple calls to <em>puts()</em>.</p>
<p>4. You must have a Makefile that compiles your program. For all C compiling, including the output of the lex and yacc commands, it must use -Wall as a compilation flag. It must have a "clean" target that removes all auto-generated files, including those from lex and yacc; it must have a "test" target that invokes your mini-compiler program on a hello-world example source file, and then invokes gcc on your resulting assembly source file.</p>
<p>5. Your code must have zero warnings under the -Wall flag usage.</p>
<p>6. Submit a zip file with your lex, yacc, and C source files (not generated ones), and your Makefile and the test program referred to in your "test" target.</p>
<p>That's it!</p>
<h3>Submission</h3>
<p>Submit your assignment by committing it into your Github repo under a "compiler1" directory. Be sure to NOT include any intermediate files produced by building your compiler, including *.o, executable, and&nbsp; the C files created by lex and yacc.</p>
<h3>Hints and Help</h3>
<p>Above the rules section in your yacc source file, you will want to have something like this:</p>
<pre>/* token value data types */<br />%union { int ival; char* str; }<br /><br />/* Starting non-terminal */<br />%start prog<br />%type &lt;str&gt; function statements statement funcall<br /><br />/* Token types */<br />%token &lt;ival&gt; NUMBER COMMA SEMICOLON LPAREN RPAREN LBRACE RBRACE<br />%token &lt;str&gt; ID STRING </pre>
<p>This tells both lex and yacc that we are going to have two data types for tokens: some tokens will have an integer type, and some will have a string (char*) type. The %token lines tells lex which token names (uppercase names) are associated with which type. More than that, the yacc nonterminals also can have these types, and the %type line tells yacc which nonterminals have which types.</p>
<p>In this file <a class="instructure_file_link" title="lexyacc0.zip" href="https://nmsu.instructure.com/courses/1693144/files/267993087/download?wrap=1" data-api-endpoint="https://nmsu.instructure.com/api/v1/courses/1693144/files/267993087" data-api-returntype="File">lexyacc0.zip</a> is a small example of a lex input specification, a yacc input specification, and examples of compiling them together (and the scanner alone). Use this to guide how you do things.</p>
<p>You should make all your nonterminals return a string (through $$) that is the assembly code that does what the nonterminal means. So <em>funcall</em> returns a string that is the assembly code for creating the string argument and calling the function (in the example output above, this is the call instruction and the movl instruction just above it). The single <em>statement</em> just returns the exact code string from its subordinate rule (i.e., <em>funcall</em>). Multiple statements just get their code strings concatenated together. A function definition adds the function preamble and postamble to the statements code. And so on.</p>
<p>The <em>funcall</em> action must also remember the actual string argument somewhere, and obtain an integer id for it (to generate the label). The easiest way to do this is to create two functions in the bottom section of your parser input file: one function that stores a string into an array and returns its index as the id; and a second that when called generates the proper declaration code for the data section for all the strings that have been registered in the array. Finally, the main <em>prog</em> action should call the code generation function before it outputs the function's code.</p>
<p>How to create the code strings that are returned from the nonterminal action blocks? The easiest way I know of is by using the <em><strong>sprintf</strong></em>() function from the C library. This allows you to use the string formatting capability of <em>printf</em>, but instead of outputting it, it places it into a string -- hence, <em><strong>s</strong>printf</em>! The target (output) string is the first argument, then the format string is the second argument, and then the format parameters are the rest of the arguments (just like printf). For example, here's my production rule and action block for <em>funcall</em>:</p>
<pre>funcall: ID LPAREN STRING RPAREN SEMICOLON<br />   {<br />      printf("function call!\n");<br />      int sid = addString($3);<br />      char *code = (char*) malloc(128);<br />      sprintf(code,"\tmovl\t$.LC%d, %%edi\n\tcall\t%s\n",sid,$1);<br />      $$ = code;<br />   }</pre>
<p>The first printf call is just for debugging. The second line declares my string id variable and sets it to the value returned by my addString() function, which will store the string in an array, for use later, and returns the index used. I declare a char* variable named code to represent my code string, and then allocate memory for the string. <strong>You cannot use an array to do this</strong>, you must allocate new space! Another match of the production rule would overwrite your single array if that's all you had. Then I <em>sprintf</em> my code string into my space, and the final line returns it to the next grammar rule up. My code string is two assembly instruction lines, properly formatted with a beginning tab and a tab to the instruction parameters; the string id becomes part of the label, and the function name ($1) is used on the call instruction.</p>
<p>Note: You should not be overspecific in your lex patterns. In this simple program, your only function is "main", but you should <strong>not</strong> write a pattern with "main" in it, you should write a pattern that recognizes valid C identifiers (or at least, most of them). The same pattern that recognizes "main" and associates it with an ID token should also recognize "puts" and associate it with an ID token. Your goal in patterns is to be as generic as possible. That said, obviously many punctuation symbols are very specific in meaning and they need to be their own pattern (i.e., "{" is a pattern all by itself). For your pattern to match the constant string, you shouldn't just match "Hello World!", but rather any valid C string (well, don't worry about trying to support a string with an embedded double-quote in it (C uses \" to allow embedding into a string; you don't have to support this)); essentially, you should recognize any sequence of non-double-quote characters that begin and end with a double quote as a valid string constant.</p>
<p>Note: As you are building your scanner, the "-d" option on lex can be very handy, as it will print out what rules it is matching. If it prints out "matching default rule" anywhere, this means that some part of the input isn't matching any of your patterns. Also, in the parser you can use the "-v" flag to get some debugging output, though it's output is a little harder to interpret. The parser's "-d" flag is not for debugging, it tells it to output token definitions into the "y.tab.h" header file that the scanner uses.</p>
<p>More help and hints later...probably!</p>
</body>
</html>

