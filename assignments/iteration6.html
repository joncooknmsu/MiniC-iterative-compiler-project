<html>
<head>
<title>
Compiler 6: Local variables, parameters, and arrays X86
</title>
</head>
<body>
<p>NOTE: edits even of deliverables are possible up to two weeks before the due date; after that, informational edits may still happen.</p>
<p>In this last iteration of our compiler project, we implement managing and accessing parameters, local variables, and array variables (global only).</p>
<h3>Short Description of Needed Functionality</h3>
<p><strong>Local variables</strong>: store their stack offset (negative) in the AST_VARREF <em>ival</em> field, and then generate code using a "%d(%%rpb)" format for accessing (or writing to) them; be sure to make space on the stack for your variables.</p>
<p><strong>Arrays (global only)</strong>: store their size in the AST_VARDECL <em>ival</em> field, then use this when generating your ".comm" declarations. When accessing, expression that is used as index will be in %eax, first do "cltq" and then use Intel indirect addressing form of "movl A(,%rax,4), %eax" can be used (notes: A is array name; 4 is the multiply factor for %rax (i.e., the size of array elements); indirect addressing must use %rax and so the "cltq" instruction converts the int in %eax (the result of the index expression) into a long in %rax). For assigning to an array, it's all very similar BUT you must use push and pop to save the value of the assignment right-hand-side expression while you compute the index expression. Kind of like the two subexpressions of a binary operator, but different uses of them.</p>
<p><strong>Parameters (up to six)</strong>: store the parameter position (starting with 1) in the AST_VARREF <em>ival</em> field, then generate code that accesses the correct position register from your <em>argRegStr</em> array. It would be convenient to start the parameters at 0 since our <em>argRegStr</em> array index starts at 0, but we've been using an <em>ival</em> field of 0 to indicate a simple global variable, so we should reserve 0 for that. Now, 0 means simple global variable, positive means a parameter position, and negative means a local variable offset.</p>
<p><strong>NOTE</strong>: to get some of that information from the parser rules into the AST nodes, we also enhance the symbol table data structure to contain more information. When variables are declared, this information is set into their symbol table record, and when they are used, we not only check for the existence of their symbol table record but now use the information contained in it to generate the needed info in the AST node.</p>
<h3>New Grammar</h3>
<pre>prog: declarations functions
functions: /* empty */  | function functions
function: ID LPAREN parameters RPAREN LBRACE <strong>localdecls</strong> statements RBRACE
statements: /* empty */  | statement statements
statement: funcall SEMICOLON  | assignment SEMICOLON  | whileloop  | ifthen  | ifthenelse
assignment: ID EQUALS expression | <strong>ID LBRACKET expression RBRACKET EQUALS expression</strong> 
funcall: ID LPAREN arguments RPAREN
whileloop: KWWHILE LPAREN relexpr RPAREN LBRACE statements RBRACE
ifthen: KWIF LPAREN relexpr RPAREN LBRACE statements RBRACE
ifthenelse: KWIF LPAREN relexpr RPAREN LBRACE statements RBRACE KWELSE LBRACE statements RBRACE
arguments: /* empty */  | argument  | argument COMMA arguments
argument: expression
expression: NUMBER  | STRING  | ID  | <strong>ID LBRACKET expression RBRACKET</strong>  | expression ADDOP expression
relexpr: expression RELOP expression
parameters: /* empty */  | vardecl  | vardecl COMMA parameters
declarations: /* empty */  | vardecl SEMICOLON declarations
<strong>localdecls: /* empty */  | vardecl SEMICOLON localdecls</strong>
vardecl: KWINT ID  | KWSTRING ID  | <strong>KWINT ID LBRACKET NUMBER RBRACKET
</strong></pre>
<p>The new parts are in bold -- don't miss the "localdecls" in the function declaration! (also, this will move the positional value of the "statements" part of the function rule from $6 to $7). The global variable declarations, parameter declarations, and local variable declarations all use the same "vardecl" sub-rule. The rest of the new grammar is for recognizing array usage, in declarations, expressions, and on the left hand side of an assignment. You will need to add LBRACKET and RBRACKET to your scanner, and to the <em>intval</em> token types, and add "localdecls" to your <em>astree</em> nonterminal types.</p>
<h3>Local Variables</h3>
<p>Local variables are far different than global variables; only one copy of a global variable exists, and it exists for the lifetime of the program. Local variables only exist during the lifetime of a <strong>function call</strong>, and if the function is recursive, each call must have its own versions of the local variables. By this point in your studies, you should know that local variables are created and exist on <strong>the stack</strong>. CPUs have direct support for maintaining the function call stack, with an SP (stack pointer) register, and with push, pop, and other stack manipulation instructions.</p>
<p>If you look at the assembly code that gcc generates for the beginning of a function call, it looks like:</p>
<pre>	.globl	func<br />	.type	func, @function<br />func:<br />	pushq	%rbp<br />	movq	%rsp, %rbp<br />	subq	$32, %rsp<br /><br /></pre>
<p>We can see from the above that on the x86_64 CPU architecture (i.e., 64-bit Intel X86), there are two registers involved, %rsp and %rbp. %rsp is the stack pointer -- it always points to the top element on the stack. %rbp is used as the pointer into the current functions' stack frame (it's called the "base pointer"). The <strong>stack grows down towards lower (smaller) addresses</strong>. The first thing the function does is that it pushes the current value in %rbp onto the stack. This saves the caller's %rbp value so that when we return we can restore this value and the caller function will still work. Then it copies the current %rsp over to %rbp. This sets up %rbp as this function's frame (base) pointer. So %rbp now "points to" the top element on the stack, which means it contains the address of the memory location(s) that contains the old value of %rbp (since that was the last push onto the stack). The function then subtracts 32 from %rsp; think of this as "pushing" 32 bytes of empty space onto the stack, which this function can now use -- for local variables or temporary variables or whatever.</p>
<p>If you remember from CS 278, CPUs use various addressing modes for accessing memory. For global variables we have used <strong>direct addressing</strong>, where the instruction has the exact (direct) address that needs to be accessed. For accessing elements of an array, where the index is computed from an expression, we need to generate the address during execution; this requires <strong>indirect addressing</strong>. On the x86_64 architecture, indirect addressing looks like (in the second operand):</p>
<pre>	movl	%eax, -4(%rbp)</pre>
<p>The way to interpret this is: store the value in %eax into the memory address formed by subtracting 4 from the value in %rbp. Since %rbp was initialized by copying %rsp into it, and since (%rbp-0) is the address for the saved old value of %rbp on the stack, then storing %eax (4 bytes) at (%rbp-4) means that we are storing it on the stack, right on top of the saved old value of %rbp. This is because the 4 bytes of %rbp are stored at (%rbp-4), (%rbp-3), (%rbp-2), and (%rbp-1), little end first (x86 is little endian).</p>
<p>So, for each local variable, you need to create a new offset (-4, -8, -12, ...) and save it first in the symbol table record, then in the AST_VARDECL node, and then in the AST_VARREF node when the variable is used (see below after the section on parameters).</p>
<p>NOTE: Upon function entrance, you must make space on the stack for your local variables, and on return you must "remove" the space. For this assignment you do not need to calculate exactly how much local variable space you need, you can just assume that you'll never need more than 64 bytes of space; thus, you can just subtract 64 from %rsp at the beginning of the function. At the end, there is a nice instruction called "leave" that will reset the stack pointer back and also pop %rbp for you! (officially, "leave" copies %rbp to %rsp, and then pops %rbp). So your function entry and exit can look like:</p>
<pre>func:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; %rbp<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; %rsp, %rbp<br /> &nbsp;      subq    $64, %rsp<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ... the whole function body here
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leave<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret</pre>
<p>The "leave" instruction works no matter how much %rsp was changed in the function. DO NOT also use "popq %rbp" with "leave", because "leave" does this already!</p>
<h3>Arrays</h3>
<p>Arrays...are not variables. What?!? Well, an array is a <strong>collection</strong> of variables. Each element in the array is a variable (a box that can hold a value of a certain type). Each variable in the array has a specific <strong>name</strong> -- such as A[2] or A[31] -- its name just happens to include an integer that we call an <strong>index</strong>. In our programming languages, the elements in an array are stored contiguously in memory, so that the index acts as an <strong>address offset</strong> from the address of the beginning of the array.</p>
<p>When an array is declared, the size of the array is given. You may be using the ".long" directive to reserve space for single integer variables, or you may have switched to the ".comm" directive. The ".comm" directive is more general, and it's format and parameters are ".comm varname, size, alignment". So a directive linex such as</p>
<pre>.comm&nbsp;&nbsp;&nbsp; x, 4, 4<br />.comm&nbsp;&nbsp;&nbsp; a, 12, 32</pre>
<p>means the following: the symbol name "x" refers to space in memory for 4 bytes and it is aligned to a 4-byte address boundary; the symbol name "a" refers to space in memory for 12 bytes that is aligned to an 32-byte address boundary. In assembly, we don't actually know what kind of variables they are, but one possibility is: x is an "int" variable, and a is an array of 3 "int" variables.</p>
<h3>Parameters</h3>
<p>Recall that we are already correctly passing (up to six) arguments in a function call, so we just need to do "the reverse" to access them in the function. Since we are only handling up to six arguments, the parameters are all in the specific registers that are used for argument passing. Your compiler just needs a way to keep track of the parameter position, and then use the correct register when that parameter is referred to. Again, we will do this first in the symbol table, then in the AST_VARDECL nodes, then in the AST_VARREF nodes (we actually never use the AST_VARDECL nodes for parameters, but you should still generate them).</p>
<p><strong>NOTE</strong>: Now that we want to use our parameters, and they exist in registers, we need to be careful to protect them. For example, you may have used %rcx or %rdx as a secondary register for expressions in a binary operator, but these are the 3rd and 4th parameter registers. Also, if we call a function (e.g., printf or any other) from our function, then we have to use the parameter registers for <strong>that</strong> call, and we destroy our own values. <strong>One (easy) solution</strong> is: everywhere we need to use one or more parameter registers, just push them on the stack beforehand, and then pop them off afterwards (in reverse order). This is not efficient but it works. You don't even need to be optimal -- i.e., you could just push all 6 parameter registers onto the stack before a function call (whether or not it has 0, 1, or 6 arguments), and then pop them off afterwards. A <strong>second more efficient solution</strong>: this is what gcc actually does -- it allocates local variable space on the stack and then copies the parameters to local variable space on the stack, and then accesses the parameters from there, as local variables. Gcc is smart about this -- it only does this if it is going to need the registers, but you could just always do it and then treat all parameter accesses as local variable accesses.</p>
<h3>Symbol Table Upgrades and New Usage</h3>
<p>In our parsing rules, currently we are only checking to see if the symbol exists in the symbol table in order to continue compiling; now we need to store and retrieve some information on that symbol. The information is a new "unsigned int size" data field and a new "int offset" data field on the Symbol struct. The size field will be 0 for regular variables, and the number of elements for an array variable. The offset data field will be 0 for global variables, a negative stack offset for a local variable (e.g., -4, -8, -12, ...), and a positive parameter position for parameters.</p>
<p>We must also now correctly use the "scopeLevel" symbol data field. Our rule is: set <em>scopeLevel</em> to 0 for globals, 1 for parameters and local variables.</p>
<p><strong>NOTE</strong>: if you are currently invoking <em>addSymbol</em>() in your action blocks for the <em>vardecl</em> production rules, you should move this up to the <em>parameters</em>, <em>declarations</em>, and <em>localdecls</em> action blocks. This way you can correctly set the <em>scopeLevel</em> and other stuff. The AST node coming from the <em>vardecl</em> action has all the information in it that you need to call <em>addSymbol</em>() in the higher level scope.</p>
<h3>Managing Parameter Positions and Local Variable Offsets</h3>
<p>The easiest way to do this is to create two new global variables at the top of your parser source file, and initialize them with the correct first value (-4 for the local var offset, and 1 for the parameter position). Then increment these in their respective <em>parameter</em> and <em>localdecl</em> action blocks (by -4 for locals, and +1 for parameters). Then, <strong>(important!), reset</strong> them back to their initial values at the bottom of the <em>function</em> declaration action block; this way, they are back to the beginning for the next function declaration. <strong>Also</strong>, at the bottom of the <em>function</em> action, invoke <em>deleteScopeLevel</em>() with a scope argument of 1. This will remove all symbols associated with this function.</p>
<h3>Requirements</h3>
<p>1. All requirements from prior compiler iterations must still be working, unless superceded here.</p>
<p>2. Global arrays must work: declaring, reading, and writing.</p>
<p>3. Local integer variables must work; declaring, reading, and writing.</p>
<p>4. Parameters (up to six) must work; declaring, and reading and writing for integer parameters.</p>
<p>5. Proper symbol table scope deletion must work; variables of the same name in different scopes should work properly.</p>
<p>Submit all files required for building in a "compiler6" directory in your Git repository.</p>
<h3>More Help and Hints</h3>
<p>For generating code for a variable read (from an AST_VARREF node), first check if the node has a non-null child[0]; if so, it is an array reference, and child[0] is the index expression; then check value of <em>ival</em> field: if 0 it is a global var ref, if &lt;0 it is a local var ref, if &gt;0 it is a parameter ref. Each of these four cases has its own different code to be generated, but all of them should leave the resulting value in %eax. All of the above is assuming that you created the VARREF node appropriately -- with the index expression as child[0] if you parsed an array ref, and with <em>ival</em> set for the other variable types.</p>
<p>For generating code for a variable assignment (from an AST_ASSIGNMENT node), check if child[1] is non-null; if so, this is an assignment to an array element. Otherwise, use ival just like for the VARREF usage above, and generate the proper code to move %eax into the right place for the variable. Array assignment has two expressions, so you have to use push/pop as with binary operators, but the final code is different (refer to array-style indirect addressing as described above).</p>
<p>I literally do not use the child[0] and child[2] sub-trees from my AST_FUNCTION node; these are the parameter and local variable VARDECL lists, and there's no need to do anything with them. There is a lot we could do with them (for example, calculate how much space we need for local variables), but we are avoiding this complexity.</p>
<div class="discussion-section message_wrapper">
    <div class="message user_content enhanced" data-bind="message">
        <p>For arrays, the suggested code at the top for array access does NOT use PC-relative addressing (the (%rip) add-on) on the array name. If your platform seems to require PC-relative addressing on the array name, the below code will work:</p>
        <p>I'm assuming that your platform is requiring the array to be referred to as "A(%rip)" like other PC-relative variable names. Thus you cannot do "movl A(,%rax,4)" or something like that, because you can't do two indirect references, like "A(%rip)(,%rax,4)".</p>
        <p>The answer is to get the starting address of A into another register using the "leaq" instruction, and then use this register as the first operand in the parentheses (which is blank in the above "movl" example). So suppose we have to read a value from an element of A. We can do:</p>
        <pre>&lt;code here leaves index expression in %eax&gt;<br />cltq                  // cltq converts %eax value into %rax value<br />leaq A(%rip), %rcx<br />movl 0(%rcx,%rax,4), %eax</pre>
        <p>Then at the end the array element value should be in %eax. The complex Intel indirect addressing has a format of "CONST(REG1,REG2,ZCONST)", which equates to CONST+REG1+(REG2*ZCONST).</p>
        <p>The "leaq" (which stands for load effective address quad) puts the starting address of A into %rcx. Of course you do not need to use %rcx, and in an assignment you might already be using it for something else. Good registers to use could be %r9 or %r10.</p>
    </div>
</div>
</body>
</html>

